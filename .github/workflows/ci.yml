name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  CARGO_TERM_COLOR: always
  REGISTRY_PREFIX: EAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

concurrency:
  group: ${{ github.workflow }}-${{ github.head_ref }}
  cancel-in-progress: true

jobs:
  fmt:
    name: Format
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt
      - run: cargo fmt --all --check

  deny:
    name: Deny
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: taiki-e/install-action@cargo-deny
      - name: Run cargo deny on all crates
        run: |
          for dir in \
            lib/kels \
            lib/kels-derive \
            lib/kels-ffi \
            services/hsm \
            services/identity \
            services/kels \
            services/kels-gossip \
            services/kels-registry \
            clients/kels-cli \
            clients/kels-bench
          do
            echo "Checking $dir..."
            (cd "$dir" && cargo deny check -A no-license-field) || exit 1
          done

  clippy:
    name: Clippy
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
        with:
          components: clippy
      - uses: Swatinem/rust-cache@v2
      - run: cargo clippy --workspace --all-targets --all-features -- -D warnings

  test:
    name: Test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - uses: Swatinem/rust-cache@v2
      - run: cargo test --workspace

  build:
    name: Build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - uses: Swatinem/rust-cache@v2
      - run: cargo build --workspace --release

  coverage:
    name: Coverage
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
        with:
          components: llvm-tools-preview
      - uses: taiki-e/install-action@cargo-llvm-cov
      - uses: Swatinem/rust-cache@v2
      - name: Generate coverage report
        id: coverage
        run: |
          # Generate text summary
          cargo llvm-cov --workspace 2>&1 | tee coverage.txt
          # Extract the TOTAL line
          TOTAL=$(grep "^TOTAL" coverage.txt | awk '{print $NF}')
          echo "total=$TOTAL" >> $GITHUB_OUTPUT
      - name: Post coverage to PR
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const coverage = fs.readFileSync('coverage.txt', 'utf8');
            const total = '${{ steps.coverage.outputs.total }}';

            // Find the summary table (last ~50 lines with the data)
            const lines = coverage.split('\n');
            const tableStart = lines.findIndex(l => l.includes('Filename'));
            const summary = lines.slice(Math.max(0, lines.length - 50)).join('\n');

            const body = `## Coverage Report

            **Total Coverage: ${total}**

            <details>
            <summary>Details</summary>

            \`\`\`
            ${summary}
            \`\`\`

            </details>`;

            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(c => c.body.includes('## Coverage Report'));

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }
