/* Auto-generated by cbindgen. Do not edit. */

#ifndef LIBKELS_H
#define LIBKELS_H

/* Warning: this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Status codes returned by KELS FFI functions
 */
typedef enum KelsStatus {
    /**
     * Operation completed successfully
     */
    KELS_STATUS_OK = 0,
    /**
     * Context not initialized or invalid
     */
    KELS_STATUS_NOT_INITIALIZED = 1,
    /**
     * Divergence detected - recovery may be needed
     */
    KELS_STATUS_DIVERGENCE_DETECTED = 2,
    /**
     * KEL not found for the given prefix
     */
    KELS_STATUS_KEL_NOT_FOUND = 3,
    /**
     * KEL is frozen (contested or decommissioned)
     */
    KELS_STATUS_KEL_FROZEN = 4,
    /**
     * Network or server error
     */
    KELS_STATUS_NETWORK_ERROR = 5,
    /**
     * KEL has not been incepted yet
     */
    KELS_STATUS_NOT_INCEPTED = 6,
    /**
     * Recovery protected - adversary used recovery key, contest required
     */
    KELS_STATUS_RECOVERY_PROTECTED = 7,
    /**
     * Generic error - check kels_last_error() for details
     */
    KELS_STATUS_ERROR = 8,
} KelsStatus;

/**
 * Outcome of a recovery operation
 */
typedef enum KelsRecoveryOutcome {
    /**
     * Successfully recovered with new keys
     */
    KELS_RECOVERY_OUTCOME_RECOVERED = 0,
    /**
     * KEL contested and frozen
     */
    KELS_RECOVERY_OUTCOME_CONTESTED = 1,
    /**
     * Recovery failed - check error
     */
    KELS_RECOVERY_OUTCOME_FAILED = 2,
} KelsRecoveryOutcome;

/**
 * Opaque context for KELS operations
 */
typedef struct KelsContext KelsContext;

/**
 * Result from event operations (incept, rotate, interact, etc.)
 */
typedef struct KelsEventResult {
    enum KelsStatus status;
    /**
     * KEL prefix (owned, must be freed with kels_free_string)
     */
    char *prefix;
    /**
     * Event SAID (owned, must be freed with kels_free_string)
     */
    char *said;
    /**
     * Event version number
     */
    uint64_t version;
    /**
     * Error message if status != Ok (owned, must be freed with kels_free_string)
     */
    char *error;
} KelsEventResult;

/**
 * Result from recovery operation
 */
typedef struct KelsRecoveryResult {
    enum KelsRecoveryOutcome outcome;
    enum KelsStatus status;
    /**
     * KEL prefix (owned, must be freed with kels_free_string)
     */
    char *prefix;
    /**
     * Event SAID (owned, must be freed with kels_free_string)
     */
    char *said;
    /**
     * Event version number
     */
    uint64_t version;
    /**
     * Error message if outcome == Failed (owned, must be freed with kels_free_string)
     */
    char *error;
} KelsRecoveryResult;

/**
 * Result from status query
 */
typedef struct KelsStatusResult {
    enum KelsStatus status;
    /**
     * KEL prefix (owned, must be freed with kels_free_string)
     */
    char *prefix;
    /**
     * Total number of events in KEL
     */
    uint32_t event_count;
    /**
     * SAID of latest event (owned, must be freed with kels_free_string)
     */
    char *latest_said;
    /**
     * Whether divergence has been detected
     */
    bool is_divergent;
    /**
     * Whether the KEL is contested
     */
    bool is_contested;
    /**
     * Whether the KEL is decommissioned
     */
    bool is_decommissioned;
    /**
     * Whether hardware (Secure Enclave) keys are in use
     */
    bool use_hardware;
    /**
     * Error message if status != Ok (owned, must be freed with kels_free_string)
     */
    char *error;
} KelsStatusResult;

/**
 * Result from list operation
 */
typedef struct KelsListResult {
    enum KelsStatus status;
    /**
     * JSON array of prefix strings (owned, must be freed with kels_free_string)
     */
    char *prefixes_json;
    /**
     * Number of prefixes
     */
    uint32_t count;
    /**
     * Error message if status != Ok (owned, must be freed with kels_free_string)
     */
    char *error;
} KelsListResult;

/**
 * Initialize a new KELS context
 *
 * # Arguments
 * * `kels_url` - URL of the KELS server (e.g., "http://kels.example.com")
 * * `state_dir` - Directory for storing local state (KELs, keys)
 * * `prefix` - Optional existing KEL prefix to load (NULL for new)
 *
 * # Returns
 * Pointer to context, or NULL on error. Check kels_last_error() for details.
 */
struct KelsContext *kels_init(const char *kels_url, const char *state_dir, const char *prefix);

/**
 * Free a KELS context
 *
 * # Safety
 * The context pointer must have been returned by kels_init() and not already freed.
 */
void kels_free(struct KelsContext *ctx);

/**
 * Change the KELS server URL at runtime
 *
 * # Returns
 * 0 on success, -1 on error
 *
 * # Safety
 * - `ctx` must be a valid context pointer
 * - `kels_url` must be a valid C string
 */
int32_t kels_set_url(struct KelsContext *ctx, const char *kels_url);

/**
 * Create an inception event (start a new KEL)
 *
 * # Safety
 * - `ctx` must be a valid context pointer
 * - `result` must be a valid pointer to a KelsEventResult
 */
void kels_incept(struct KelsContext *ctx, struct KelsEventResult *result);

/**
 * Rotate the signing key
 *
 * # Safety
 * - `ctx` must be a valid context pointer
 * - `result` must be a valid pointer to a KelsEventResult
 */
void kels_rotate(struct KelsContext *ctx, struct KelsEventResult *result);

/**
 * Rotate the recovery key (requires dual signature)
 *
 * # Safety
 * - `ctx` must be a valid context pointer
 * - `result` must be a valid pointer to a KelsEventResult
 */
void kels_rotate_recovery(struct KelsContext *ctx, struct KelsEventResult *result);

/**
 * Create an interaction event (anchor data to KEL)
 *
 * # Arguments
 * * `anchor` - The data to anchor (e.g., a hash or identifier)
 *
 * # Safety
 * - `ctx` must be a valid context pointer
 * - `anchor` must be a valid C string
 * - `result` must be a valid pointer to a KelsEventResult
 */
void kels_interact(struct KelsContext *ctx, const char *anchor, struct KelsEventResult *result);

/**
 * Attempt recovery from divergence or adversary attack
 *
 * # Safety
 * - `ctx` must be a valid context pointer
 * - `result` must be a valid pointer to a KelsRecoveryResult
 */
void kels_recover(struct KelsContext *ctx, struct KelsRecoveryResult *result);

/**
 * Decommission a KEL (permanently disable it)
 *
 * # Safety
 * - `ctx` must be a valid context pointer
 * - `result` must be a valid pointer to a KelsEventResult
 */
void kels_decommission(struct KelsContext *ctx, struct KelsEventResult *result);

/**
 * Get the status of the current KEL
 *
 * # Arguments
 * * `prefix` - Optional prefix to query (NULL for current context's KEL)
 *
 * # Safety
 * - `ctx` must be a valid context pointer
 * - `result` must be a valid pointer to a KelsStatusResult
 */
void kels_status(struct KelsContext *ctx, const char *_prefix, struct KelsStatusResult *result);

/**
 * Get the full KEL as JSON
 *
 * # Arguments
 * * `prefix` - The KEL prefix to fetch
 *
 * # Returns
 * JSON string of events, or NULL on error. Must be freed with kels_free_string().
 *
 * # Safety
 * - `ctx` must be a valid context pointer
 * - `prefix` must be a valid C string
 */
char *kels_get_kel(struct KelsContext *ctx, const char *prefix);

/**
 * List all local KEL prefixes
 *
 * # Safety
 * - `ctx` must be a valid context pointer
 * - `result` must be a valid pointer to a KelsListResult
 */
void kels_list(struct KelsContext *ctx, struct KelsListResult *result);

/**
 * Free a KelsEventResult's allocated strings
 *
 * # Safety
 * The result must have been populated by a KELS function.
 */
void kels_event_result_free(struct KelsEventResult *result);

/**
 * Free a KelsStatusResult's allocated strings
 *
 * # Safety
 * The result must have been populated by a KELS function.
 */
void kels_status_result_free(struct KelsStatusResult *result);

/**
 * Free a KelsListResult's allocated strings
 *
 * # Safety
 * The result must have been populated by a KELS function.
 */
void kels_list_result_free(struct KelsListResult *result);

/**
 * Free a KelsRecoveryResult's allocated strings
 *
 * # Safety
 * The result must have been populated by a KELS function.
 */
void kels_recovery_result_free(struct KelsRecoveryResult *result);

/**
 * Free a string returned by KELS functions
 *
 * # Safety
 * The string must have been returned by a KELS function.
 */
void kels_free_string(char *s);

/**
 * Get the last error message
 *
 * # Returns
 * Error string or NULL if no error. String is valid until next KELS call.
 * Do NOT free this string.
 */
const char *kels_last_error(void);

#if defined(DEV_TOOLS)
/**
 * Inject adversary events for testing divergence scenarios
 *
 * # Arguments
 * * `event_types` - Comma-separated event types to inject (e.g., "rot,ixn")
 *
 * # Returns
 * 0 on success, -1 on error
 *
 * # Safety
 * - `ctx` must be a valid context pointer
 * - `event_types` must be a valid C string
 */
int32_t kels_adversary_inject_events(struct KelsContext *ctx, const char *event_types);
#endif

#if defined(DEV_TOOLS)
/**
 * Truncate the local KEL, keeping only the first N events
 *
 * # Arguments
 * * `keep_events` - Number of events to keep
 *
 * # Returns
 * 0 on success, -1 on error
 *
 * # Safety
 * - `ctx` must be a valid context pointer
 */
int32_t kels_truncate_local_kel(struct KelsContext *ctx, uint32_t keep_events);
#endif

#if defined(DEV_TOOLS)
/**
 * Dump the local KEL for debugging
 *
 * # Returns
 * JSON string of the KEL, or NULL on error. Must be freed with kels_free_string().
 *
 * # Safety
 * - `ctx` must be a valid context pointer
 */
char *kels_dump_local_kel(struct KelsContext *ctx);
#endif

/**
 * Reset all local state (KELs, keys, owner tails)
 *
 * This removes all local KEL data and key state files from the state directory.
 * After calling this, you must create a new context and incept a new KEL.
 *
 * # Arguments
 * * `state_dir` - Directory containing local state to clear
 *
 * # Returns
 * 0 on success, -1 on error
 *
 * # Safety
 * - `state_dir` must be a valid C string
 */
int32_t kels_reset(const char *state_dir);

#endif  /* LIBKELS_H */
